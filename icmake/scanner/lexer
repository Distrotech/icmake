%filenames scanner
%x str comment

OPTBL   [[:blank:]]*
BL      [[:blank:]]+
IDENT   [_[:alpha:]][_[:alnum:]]*

DEFINE      {OPTBL}#define{BL}.*
IFDEF       {OPTBL}#ifdef{BL}{IDENT}
IFNDEF      {OPTBL}#ifndef{BL}{IDENT}
UNDEF       {OPTBL}#undef{BL}{IDENT}
INCLUDE     {OPTBL}#include{BL}\".*\"{OPTBL}
IM_INCLUDE  {OPTBL}#include{BL}<.*>{OPTBL}

%%

//.*                |
{BL}                blanks();

"/*"                comment();

^{INCLUDE}$         changeFile();
^{IM_INCLUDE}$      changeImFile();
^{DEFINE}           define();
^{IFDEF}            ifdef();
^{IFNDEF}           ifndef();
^{UNDEF}            undef();

\n                  newline();


'.'                     {
                            sprintf(lexstring, "%d%c", yytext[1], 0);
                            return token(Parser::NUMBER);
                        }

"++"                    return opcode(Opcode::INC);
"--"                    return opcode(Opcode::DEC);
"/="                    return opcode(Opcode::DIV_IS);
"-="                    return opcode(Opcode::MINUS_IS);
"*="                    return opcode(Opcode::MUL_IS);
"%="                    return opcode(Opcode::MOD_IS);
"+="                    return opcode(Opcode::PLUS_IS);
"&="                    return opcode(Opcode::AND_IS);
"|="                    return opcode(Opcode::OR_IS);
"^="                    return opcode(Opcode::XOR_IS);
"<<="                   return opcode(Opcode::SHL_IS);
">>="                   return opcode(Opcode::SHR_IS);
"||"                    return opcode(Opcode::OR);
"&&"                    return opcode(Opcode::AND);
"=="                    return opcode(Opcode::EQUAL);
"!="                    return opcode(Opcode::NOT_EQUAL);
"<="                    return opcode(Opcode::SMALLER_EQUAL);
">="                    return opcode(Opcode::GREATER_EQUAL);
">>"                    return opcode(Opcode::SHR);
"<<"                    return opcode(Opcode::SHL);

0x[0-9]+                return hexNumber();
                            unsigned value;
                            sscanf(yytext + 2, "%x", &value);
                            sprintf(lexstring, "%d", (int)value);
                            return(NUMBER);

[0-9]+                  return decNumber();
                            lexstring = xstrdup(yytext);
                            return(NUMBER);
OFF                     |
P_CHECK                 return mode(Mode::P_CHECK);
                            {                   /* P_CHECK: value in icm.h */
                            lexstring = xstrdup("0");
                            return(NUMBER);
                        }
ON                      |
O_FILE                  |
S_IFDIR                 return mode(Mode::S_IFDIR);
ON                      {
                            lexstring = xstrdup("1");
                            return(NUMBER);
                        }
S_IFCHR     |
P_NOCHECK   
O_DIR                   {                   /* O_DIR: value in icm.h */
                            lexstring = xstrdup("2");
                            return(NUMBER);
                        }
S_IFREG     |
O_SUBDIR                {                   /* O_SUBDIR: value in icm.h */
                            lexstring = xstrdup("4");
                            return(NUMBER);
                        }
S_IREAD     |
O_ALL                   {                   /* O_ALL: value in icm.h */
                            lexstring = xstrdup("8");
                            return(NUMBER);
                        }
S_IWRITE                {
                            lexstring = xstrdup("16");
                            return(NUMBER);
                        }
S_IEXEC                 {
                            lexstring = xstrdup("32");
                            return(NUMBER);
                        }

{IDENT}                 return token(Parser::IDENTIFIER);

.                       return opcode(RSS::);


<comment>{
    "*/"                begin(StartCondition__::initial);
    .|\n                ;
}

<str>{
    \"                 return token(Parser::STRING);
                        {
                            BEGIN 0;
                            if (!stresc(lexstring))
                                semantic("illegal escape sequence in string");
                            return Parser::STRING;
                        }

    .                   |
    \\.                 more();
}


