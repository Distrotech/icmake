%filenames scanner
%x str comment

OPTBL   [[:blank:]]*
BL      [[:blank:]]+
IDENT   [_[:alpha:]][_[:alnum:]]*

DEFINE      {OPTBL}#define{BL}.*
IFDEF       {OPTBL}#ifdef{BL}{IDENT}
IFNDEF      {OPTBL}#ifndef{BL}{IDENT}
UNDEF       {OPTBL}#undef{BL}{IDENT}
INCLUDE     {OPTBL}#include{BL}\".*\"{OPTBL}
IM_INCLUDE  {OPTBL}#include{BL}<.*>{OPTBL}

%%

//.*                |
{BL}                blanks();

"/*"                comment();

^{INCLUDE}$         changeFile();
^{IM_INCLUDE}$      changeImFile();
^{DEFINE}           define();
^{IFDEF}            ifdef();
^{IFNDEF}           ifndef();
^{UNDEF}            undef();

\n                  newline();


'.'                     {
                            sprintf(lexstring, "%d%c", yytext[1], 0);
                            return(NUMBER);
                        }

getch                   |
getpid                  |
gets                    return zero_arg_function();

arghead                 |
argtail                 |
ascii                   |
cmdtail                 |
cmdhead                 |
echo                    |
exists                  |
get_base                |
getenv                  |
get_ext                 |
get_path                |
putenv                  |
sizeof                  |
sizeoflist              |
strlen                  |
strlwr                  |
strupr                  return oneArgFunction();

change_base             |
change_ext              |
change_path             |
element                 |
fgets                   |
strtok                  return twoArgFunction();

substr                  return threeArgFunction();

chdir                   return function(CHDIR);
stat                    return function (STAT);
system                  return function(SYSTEM);

fprintf                 return function(FPRINTF);


break                   return function(BREAK);
else                    return function(ELSE);
for                     return function(FOR);
if                      return function(IF);
int                     return function(INT);
void                    return function (VOID);
return                  return function(RETURN);
while                   return function(WHILE);

exec                    return function(EXEC);
execute                 return function(EXECUTE);

exit                    return function(EXIT);

list                    return function(LIST);
makelist                return function(MAKELIST);
printf                  return function(PRINTF);
string                  return function(STRINGTYPE);
strfind                 return function STRFIND;

older                   return function(OLDER);

newer                   |
younger                 return function(YOUNGER);

"++"                    return function(INC);
"--"                    return function(DEC);
"/="                    return function(DIV_IS);
"-="                    return function(MINUS_IS);
"*="                    return function(MUL_IS);
"%="                    return function(MOD_IS);
"+="                    return function(PLUS_IS);
"&="                    return function(AND_IS);
"|="                    return function(OR_IS);
"^="                    return function(XOR_IS);
"<<="                   return function(SHL_IS);
">>="                   return function(SHR_IS);
"||"                    return function(OR);
"&&"                    return function(AND);
"=="                    return function(EQUAL);
"!="                    return function(NOT_EQUAL);
"<="                    return function(SMALLER_EQUAL);
">="                    return function(GREATER_EQUAL);
">>"                    return function(SHR);
"<<"                    return function(SHL);

0x[0-9]+                return hexNumber();
                            unsigned value;
                            sscanf(yytext + 2, "%x", &value);
                            sprintf(lexstring, "%d", (int)value);
                            return(NUMBER);

[0-9]+                  return decNumber();
                            lexstring = xstrdup(yytext);
                            return(NUMBER);
OFF                     |
P_CHECK                 return ...
                            {                   /* P_CHECK: value in icm.h */
                            lexstring = xstrdup("0");
                            return(NUMBER);
                        }
S_IFDIR     |
O_FILE      |                               /* O_FILE: value in icm.h */
ON                      {
                            lexstring = xstrdup("1");
                            return(NUMBER);
                        }
S_IFCHR     |
P_NOCHECK   |
O_DIR                   {                   /* O_DIR: value in icm.h */
                            lexstring = xstrdup("2");
                            return(NUMBER);
                        }
S_IFREG     |
O_SUBDIR                {                   /* O_SUBDIR: value in icm.h */
                            lexstring = xstrdup("4");
                            return(NUMBER);
                        }
S_IREAD     |
O_ALL                   {                   /* O_ALL: value in icm.h */
                            lexstring = xstrdup("8");
                            return(NUMBER);
                        }
S_IWRITE                {
                            lexstring = xstrdup("16");
                            return(NUMBER);
                        }
S_IEXEC                 {
                            lexstring = xstrdup("32");
                            return(NUMBER);
                        }

{IDENT}                 return function(IDENTIFIER);

.                       return function();


<comment>{
    "*/"            begin(StartCondition__::initial);
    .|\n            ;
}

<str>{
    \"                 {
                            BEGIN 0;
                            if (!stresc(lexstring))
                                semantic("illegal escape sequence in string");
                            return Parser::STRING;
                        }

    .                   |
    \\.                 more();
}

