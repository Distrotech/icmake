%filenames scanner 
%x ignore str comment define imfile
%debug

OPTBL   [[:blank:]]*
BL      [[:blank:]]+
IDENT   [_[:alpha:]][_[:alnum:]]*

DEFINE      {OPTBL}#{OPTBL}define{BL}{IDENT}({BL}.)?
IFDEF       {OPTBL}#{OPTBL}ifdef{BL}{IDENT}
IFNDEF      {OPTBL}#{OPTBL}ifndef{BL}{IDENT}
UNDEF       {OPTBL}#{OPTBL}undef{BL}{IDENT}
ELSE        {OPTBL}#{OPTBL}else
ENDIF       {OPTBL}#{OPTBL}endif
INCLUDE     {OPTBL}#{OPTBL}include{BL}\"
IM_INCLUDE  {OPTBL}#{OPTBL}include{BL}\<
HASHBANG    {OPTBL}#{OPTBL}!.*

%%

"//".*                  |
{BL}                    blanks();

"/*"                    comment();
^{HASHBANG}             // ignore
^{UNDEF}                undef();
^{DEFINE}               beginDefine();
<define>[[:alnum:]]+    define(d_matched);

^{INCLUDE}              beginFile();
^{IM_INCLUDE}           begin(StartCondition__::imfile);
<imfile>{               
    \>                  changeImFile(); 
    .                   |
    \\.                 more();
}

<INITIAL,ignore>{
    ^{IFDEF}            ifdef();
    ^{IFNDEF}           ifndef();
    ^{ELSE}             ppElse();
    ^{ENDIF}            endif();
}

<ignore>.|\n        // ignore

\n                  newline();

break               return plain(Parser::BREAK);
else                return plain(Parser::ELSE);
for                 return plain(Parser::FOR);
if                  return plain(Parser::IF);
void                return plain(Parser::VOID);
while               return plain(Parser::WHILE);

//'.'                     {
//                            sprintf(lexstring, "%d%c", yytext[1], 0);
//                            return token(Parser::NUMBER);
//                        }

int                 |       // var_type
list                |
string              |
return              |       // leave
exit                |
"=="                |       // equality
"!="                |
"<="                |       // comparison
">="                |
'<'                 |
'>'                 |
newer               |
younger             |
older               |
">>"                |       // shift
"<<"                |
'+'                 |       // add
'-'                 |
'*'                 |       // mul
'/'                 |
'%'                 |
"++"                |       // inc
"--"                |       // dec
'!'                 |       // unop
'~'                 |
"/="                |       // assign
"-="                |  
"*="                |
"%="                |
"+="                | 
"&="                |
"|="                |
"^="                |
"<<="               |
">>="               |
'='                 |
"||"                |       // or
"&&"                |       // and
OFF                 |       // mode values
ON                  |
O_ALL               |
O_DIR               |
O_FILE              |
O_SUBDIR            |
P_CHECK             |
P_NOCHECK           |
S_IEXEC             |
S_IFCHR             |
S_IFDIR             |
S_IFREG             |
S_IREAD             |
S_IWRITE            return parserToken();

0x[[:xdigit:]]+     return hexNumber();
[0-9]+              return number();

"${"{IDENT}'}'      replaceDefine();

{IDENT}             identifier();

\"                  dQuote();
.                   return charToken();

<comment>{
    "*/"            begin(StartCondition__::INITIAL);
    .|\n            ;
}

<str>{
    \"              str();          // also unescapes, returns STRING or
                                    // installs a define
    .               |
    \\.             more();
}





